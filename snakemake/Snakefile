import os
import glob
import subprocess
import pandas as pd

# Define a function to extract the sample name from a fastq.gz filename
def extract_sample_name(filename):
    # Get the base filename without the directory
    base_filename = os.path.basename(filename)
    
    # Split the filename by underscores
    parts = base_filename.split('_')
    
    # Find the part that contains 'L001' and get the sample name before it
    for i, part in enumerate(parts):
        if 'L001' in part:
            return '_'.join(parts[:i])

# Defining wildcard for haplotype and sequence batch #
wildcard_constraints:
    hap = r'1|2',
    batch = r'1|2'

# Directory containing the fastq.gz files 
# Change 1 to {batch}
directory = "data/batch_1"

# Get a list of all fastq.gz files in the directory
fastq_files = glob.glob(os.path.join(directory, "*.fastq.gz"))

# Initialize a set to store unique sample names
SAMPLES = set()

# Iterate over the fastq.gz files and extract sample names
for filename in fastq_files:
    sample_name = extract_sample_name(filename)
    SAMPLES.add(sample_name)

# Convert the set to a sorted list for consistent order
SAMPLES = sorted(list(SAMPLES))
POPULATIONS = ("HPW", "IDNP-MW", "LCTGP", "MFNP", "PPP", "RLPLV", "SWCP")
POPULATIONS2 = ("CSS", "FMB", "")

with open("results/scaffolds/hap1_scaffolds.txt", "r") as file:
    HAP1SCAFFOLDS = [line.strip() for line in file.readlines()]

with open("results/scaffolds/hap2_scaffolds.txt", "r") as file:
    HAP2SCAFFOLDS = [line.strip() for line in file.readlines()]

# Split scaffold names by comma and create a list
HAP1SCAFFOLDS = [name.strip() for name in HAP1SCAFFOLDS]
HAP2SCAFFOLDS = [name.strip() for name in HAP2SCAFFOLDS]
HAP1SCAFFOLD_PREFIXES = [s.split("__")[0] for s in HAP1SCAFFOLDS]
HAP2SCAFFOLD_PREFIXES = [s.split("__")[0] for s in HAP2SCAFFOLDS]

# Function give full scaffold name given prefix of scaffold
def map_prefix_to_full_scaffold(prefix, hap_type):
    scaffold_list = HAP1SCAFFOLDS if hap_type == 1 else HAP2SCAFFOLDS
    for scaffold in scaffold_list:
        if scaffold.startswith(prefix):
            return scaffold
    return None  # Return None or an appropriate default if not found

BH_VARS=[50,40,30,20,10,5]


# Update the SAMPLES list with merged sample names 
# ONLY INCLUDE AFTER rule merge_replicates IS RUN. MUST RUN WORKFLOW AT 2 POINTS. !!!
merged_samples = ["MFNP-48_2_269001_S193", "IDNP-MW-6_2_269002_S194", "RLPLV-13_2_269003_S195"]
samples_to_remove = ["MFNP-48_2-2695929_S1", "MFNP-48_2-2697940_S99", "IDNP-MW-6_2-2698020_S129", "IDNP-MW-6_2-2698118_S177", "RLPLV-13_2-2696026_S48", "RLPLV-13_2-2696110_S82"]
SAMPLES = set([sample for sample in SAMPLES if sample not in samples_to_remove])
SAMPLES.update(merged_samples)
SAMPLES = sorted(list(SAMPLES))

###########################
## BEGINNING OF WORKFLOW ##
###########################


# final files desired (can change)
rule all:
  input:
    expand("results/angsd/hap2/canonical_realign/by_popln/{population}_canonical_sites.arg", population=POPULATIONS),
    expand("results/angsd/hap2/canonical_realign/by_popln/{population}_canonical_sites.mafs.gz", population=POPULATIONS),
    expand("results/angsd/hap2/canonical_realign/by_popln/{population}_canonical_sites.hwe.gz", population=POPULATIONS),
    expand("results/angsd/hap2/canonical_realign/by_popln/{population}_canonical_sites.depthSample", population=POPULATIONS),
    expand("results/angsd/hap2/canonical_realign/by_popln/{population}_canonical_sites.depthGlobal", population=POPULATIONS),
    expand("results/angsd/hap2/canonical_realign/by_popln/{population}_canonical_sites.saf.idx", population=POPULATIONS),
    expand("results/angsd/hap2/canonical_realign/by_popln/{population}_canonical_sites.saf.pos.gz", population=POPULATIONS),
    expand("results/angsd/hap2/canonical_realign/by_popln/{population}_canonical_sites.saf.gz", population=POPULATIONS),
    "results/angsd/hap2/canonical_realign/all_poplns/all_poplns_canonical_SNPs.arg",
    "results/angsd/hap2/canonical_realign/all_poplns/all_poplns_canonical_SNPs.mafs.gz",
    "results/angsd/hap2/canonical_realign/all_poplns/all_poplns_canonical_SNPs.hwe.gz",
    "results/angsd/hap2/canonical_realign/all_poplns/all_poplns_canonical_SNPs.depthSample",
    "results/angsd/hap2/canonical_realign/all_poplns/all_poplns_canonical_SNPs.depthGlobal",
    "results/angsd/hap2/canonical_realign/all_poplns/all_poplns_canonical_SNPs.saf.idx",
    "results/angsd/hap2/canonical_realign/all_poplns/all_poplns_canonical_SNPs.saf.pos.gz",
    "results/angsd/hap2/canonical_realign/all_poplns/all_poplns_canonical_SNPs.saf.gz",
    expand("results/ngs_paralog/hap2/dupHMM_realign/{population}_scaffolds/{population}-{hap2scaffold_prefix}_dupHMM_realign_run.rf", population=("MFNP", "LCTGP", "IDNP-MW"), hap2scaffold_prefix=HAP2SCAFFOLD_PREFIXES)









#### DATA PREPARATION ####

# Trim adapter ends off each sequence file using Trimmomatic 
# When batch 2 is available, use wildcard {batch}
rule trim_reads:
  input:
    r1="data/batch_{batch}/{sample}_L001_R1_001.fastq.gz",
    r2="data/batch_{batch}/{sample}_L001_R2_001.fastq.gz",
  output:
    r1="results/trimmed/{sample}_R1.fastq.gz",
    r1_unp="results/trimmed/{sample}_R1_unpaired.fastq.gz",
    r2="results/trimmed/{sample}_R2.fastq.gz",
    r2_unp="results/trimmed/{sample}_R2_unpaired.fastq.gz"
  log:
    "results/logs/trim_reads/{sample}.log"
  envmodules:
    "trimmomatic/0.39"
  params:
    adapters="$EBROOTTRIMMOMATIC/adapters/TruSeq3-PE-2.fa"
  shell:
    "java -jar $EBROOTTRIMMOMATIC/trimmomatic-0.39.jar PE {input.r1} {input.r2} "
    "{output.r1} {output.r1_unp} {output.r2} {output.r2_unp} "
    "ILLUMINACLIP:{params.adapters}:2:30:10 "
    "LEADING:3 "
    "TRAILING:3 "
    "SLIDINGWINDOW:4:15 "
    "MINLEN:36 2> {log}"


# Unzip trimmed files as fastqc 0.12.0 cannot properly read compressed files
rule unzip_files:
  input:
    zipped_r1="results/batch_{batch}/trimmed/{sample}_R1.fastq.gz",
    zipped_r2="results/batch_{batch}trimmed/{sample}_R2.fastq.gz"
  output: 
    unzipped_r1="results/batch_{batch}/trimmed_unzip/{sample}_R1.fastq",
    unzipped_r2="results/batch_{batch}/trimmed_unzip/{sample}_R2.fastq"
  shell:
    "gunzip -c {input.zipped_r1} > {output.unzipped_r1} && gunzip -c {input.zipped_r2} > {output.unzipped_r2}"


# Run FastQC per each trimmed sequence file
rule fastqc:
  input:
    fastq_r1="results/trimmed_unzip/batch_{batch}/{sample}_R1.fastq",
    fastq_r2="results/trimmed_unzip/batch_{batch}/{sample}_R2.fastq"
  output:
    html_report_r1="results/fastqc/batch_{batch}/{sample}_R1_fastqc.html",
    zip_report_r1="results/fastqc/batch_{batch}/{sample}_R1_fastqc.zip",
    html_report_r2="results/fastqc/batch_{batch}/{sample}_R2_fastqc.html",
    zip_report_r2="results/fastqc/batch_{batch}/{sample}_R2_fastqc.zip"
  envmodules:
    "fastqc/0.12.0"
  shell:
    "fastqc {input.fastq_r1} {input.fastq_r2} --outdir results/fastqc"


# Create an aggregated FastQC report using MultiQC.
# Note that we create separate MultiQC reports for both batch 1 and 2
rule multiqc_raw:
  input:
    fastqc_dir="results/fastqc/batch_{batch}"
  output:
    html_report="results/multiqc/multiqc_raw_batch_{batch}/multiqc_report.html"
  params:
    output_dir="results/multiqc/multiqc_raw_batch_{batch}"
  shell:
    "multiqc -o {params.output_dir} {input.fastqc_dir} "


# Creating faidx index for reference genome
rule faidx_reference:
  input:
    "data/reference/hap{hap}/lupinehap{hap}.fasta",
  output:
    "data/reference/hap{hap}/lupinehap{hap}.fasta.fai",
  log:
    "results/logs/refgen/lupinehap{hap}_faidx.log",
  envmodules:
    "samtools/1.17"
  shell:
    "samtools faidx {input} 2> {log} "


# Rules for indexing reference genomes (haplotypes 1 and 2)
rule index_reference:
  input:
    "data/reference/hap{hap}/lupinehap{hap}.fasta"
  output:
    multiext("data/reference/hap{hap}/lupinehap{hap}.fasta", ".amb", ".ann", ".bwt", ".pac", ".sa"),
  log:
    "results/logs/refgen/lupinehap{hap}_bwa_index.log"
  envmodules:
    "bwa/0.7.17"
  shell:
    "bwa index {input} 2> {log}"


# Rules for creating dictionary files
rule create_dict:
  input:
    "data/reference/hap{hap}/lupinehap{hap}.fasta"
  output:
    "data/reference/hap{hap}/lupinehap{hap}.dict"
  log:
    "results/logs/refgen/hap{hap}_dict.log"
  envmodules:
    "samtools/1.17"
  shell:
    "samtools dict {input} > {output} 2> {log}"


# Mapping/Aligning reads to haplotypes
rule map_reads:
  input:
    r1="results/trimmed/{sample}_R1.fastq.gz",
    r2="results/trimmed/{sample}_R2.fastq.gz",
    genome="data/reference/hap{hap}/lupinehap{hap}.fasta",
    idx=multiext("data/reference/hap{hap}/lupinehap{hap}.fasta", ".amb", ".ann", ".bwt", ".pac", ".sa")
  output:
    "results/bam/hap{hap}/{sample}_hap{hap}.bam"
  log:
    "results/logs/map_reads/hap{hap}/{sample}_hap{hap}.log"
  benchmark:
    "results/benchmarks/map_reads/{sample}_hap{hap}.bmk"
  envmodules:
    "bwa/0.7.17",
    "samtools/1.17"
  threads: 8 
  params:
    RG="-R '@RG\\tID:{sample}\\tSM:{sample}\\tPL:ILLUMINA' "
    # Excluded information on flowcell, lane, and barcode index b/c not thought necessary
  shell:
    " (bwa mem {params.RG} -t {threads} {input.genome} {input.r1} {input.r2} | "
    " samtools view -u | "
    " samtools sort - > {output}) 2> {log}"













#### DATA QUALITY CONTROL ####

# Steps in QC :
  # 1. Mark PCR and optical duplicates
  # 2. Identify paralogous regions due to duplication events
      # - Requires ngsParalog and 1st run of ANGSD
      # - ANGSD: SNP call and input SNPs (aka polymorphic sites) into ngsParalog
      # - ngsParalog: probablistic call of paralogous regions
      # - After ngsParalog, calculate p-values based on chi-sq df = 1 with Benjamini-Hochberg correction
  # 3. Verify heterozygote excess is reduced
      # - Re-run ANGSD excluding paralogous regions and PCR duplicates
      #   - Visualize SFS

## STEP 1: MERGE REPLICATES & MARK PCR & OPTICAL DUPLICATES 

# Merge replicates
rule merge_replicates:
  input:
    MFNP_48A="results/bam/hap{hap}/MFNP-48_2-2695929_S1_hap{hap}.bam",
    MFNP_48B="results/bam/hap{hap}/MFNP-48_2-2697940_S99_hap{hap}.bam",
    IDNP_6A="results/bam/hap{hap}/IDNP-MW-6_2-2698020_S129_hap{hap}.bam",
    IDNP_6B="results/bam/hap{hap}/IDNP-MW-6_2-2698118_S177_hap{hap}.bam",
    RLPLV_13A="results/bam/hap{hap}/RLPLV-13_2-2696026_S48_hap{hap}.bam",
    RLPLV_13B="results/bam/hap{hap}/RLPLV-13_2-2696110_S82_hap{hap}.bam"
  output:
    MFNP_48="results/bam/hap{hap}/MFNP-48_2_269001_S193_hap{hap}.bam",
    IDNP_6="results/bam/hap{hap}/IDNP-MW-6_2_269002_S194_hap{hap}.bam",
    RLPLV_13="results/bam/hap{hap}/RLPLV-13_2_269003_S195_hap{hap}.bam"
  params:
    archive="results/bam/archive/hap{hap}"
  envmodules:
    "samtools/1.17"
  shell:
    """
    samtools merge -o {output.MFNP_48} {input.MFNP_48A} {input.MFNP_48B}
    samtools merge -o {output.IDNP_6} {input.IDNP_6A} {input.IDNP_6B}
    samtools merge -o {output.RLPLV_13} {input.RLPLV_13A} {input.RLPLV_13B}
    mkdir -p {params.archive}
    mv {input.MFNP_48A} {input.MFNP_48B} {input.IDNP_6A} {input.IDNP_6B} {input.RLPLV_13A} {input.RLPLV_13B} {params.archive}
    """



# Marking and removing PCR duplicates + index
# Note that: /bam_mkdup/ is where marked duplicates are marked but not removed. This is backed up in the projects folder.
rule mark_remove_duplicates:
  input:
    "results/bam/hap{hap}/{sample}_hap{hap}.bam"
  output:
    bam="results/bam_mkdup/hap{hap}/{sample}_hap{hap}_mkdup.bam",
    bai="results/bam_mkdup/hap{hap}/{sample}_hap{hap}_mkdup.bai",
    metrics="results/qc/mkdup_metrics/{sample}_hap{hap}.metrics"
  log:
    "results/logs/mark_remove_duplicates/hap{hap}/{sample}_hap{hap}.log"
  envmodules:
    "gatk/4.2.5.0"
  shell:
    """
    gatk MarkDuplicates \
    --CREATE_INDEX \
    -I {input} \
    -O {output.bam} \
    -M {output.metrics} \
    --REMOVE_DUPLICATES true \
    2> {log}
    """


# Clip overlapping reads
rule clip_overlapping_reads:
  input:
    bam="results/bam_mkdup/hap{hap}/{sample}_hap{hap}_mkdup.bam"
  output:
    clipped_bam="results/bam_clipped/hap{hap}/{sample}_hap{hap}_clipped.bam",
    clipped_index="results/bam_clipped/hap{hap}/{sample}_hap{hap}_clipped.bai"
  log:
    "results/logs/clip_overlap/hap{hap}/{sample}_clip_overlapping_reads.log"
  shell:
    """
    module --force purge
    module load nixpkgs/16.09 intel/2018.3
    module load bamutil/1.0.14
    bam clipOverlap --in {input.bam} --out {output.clipped_bam} 2> {log}
    module --force purge
    module load StdEnv/2023 samtools/1.18
    samtools index -b {output.clipped_bam} -o {output.clipped_index} --threads 2
    module --force purge
    """


# Create bam list per population for entry into realign indels
rule generate_clipped_bam_list_per_population:
  input:
    expand("results/bam_clipped/hap{hap}/{sample}_hap{hap}_clipped.bam", sample=SAMPLES, hap=(1,2)),
  output:
    "data/lists/hap{hap}/{population}_clipped_hap{hap}.list"
  wildcard_constraints:
    population="|".join(POPULATIONS)
  run:
    bam_files = input
    output_file = output[0]
    population = wildcards.population
    hap = wildcards.hap

    with open(output_file, "w") as output:
        for bam_file in bam_files:
            if population in bam_file and f"_hap{hap}_" in bam_file:
                output.write(f"{bam_file}\n")


# Create interval list of indels
rule indel_list:
  input:
    bam_list="data/lists/hap{hap}/{population}_clipped_hap{hap}.list",
    reference="data/reference/hap{hap}/lupinehap{hap}.fasta"
  output:
    intervals="data/lists/hap{hap}/{population}_hap{hap}_indels.intervals"
  log:    
    "results/logs/indel_list/hap{hap}/{population}_hap{hap}_indel_list.log"
  shell:
    """
    module --force purge
    module load nixpkgs/16.09 gatk/3.8
    java -Xmx16g \
    -jar $EBROOTGATK/GenomeAnalysisTK.jar \
    -T RealignerTargetCreator \
    -R {input.reference} \
    -I {input.bam_list} \
    -o {output.intervals} \
    -drf BadMate \
    2> {log}
    module --force purge
    """


# Realign reads around indels - necessary if using ANGSD
rule realign_indels:
  input:
    bam="results/bam_clipped/hap{hap}/{sample}_hap{hap}_clipped.bam",
    ref="data/reference/hap{hap}/lupinehap{hap}.fasta",
    intervals=lambda wildcards: "data/lists/hap" + wildcards.hap + "/" + next(pop for pop in POPULATIONS if pop in wildcards.sample) + f"_hap{wildcards.hap}_indels.intervals"
  output:
    realigned_bam="results/bam_realign/hap{hap}/{sample}_hap{hap}_realign.bam"
  log:
    "results/logs/realign_indels/hap{hap}/{sample}_hap{hap}_realign_indels.log"
  shell:
    """
    module --force purge
    module load nixpkgs/16.09 gatk/3.8
    java -Xmx16g \
    -jar $EBROOTGATK/GenomeAnalysisTK.jar \
    -T IndelRealigner \
    -I {input.bam} \
    -R {input.ref} \
    -targetIntervals {input.intervals} \
    -o {output.realigned_bam}\
    &> {log}
    module --force purge
    """







## STEP 2: IDENTIFY PARALOGOUS REGIONS 

# Rule to create .txt file of BAM files per population
rule generate_bam_list_per_population:
  input:
    expand("results/bam_realign/hap{hap}/{sample}_hap{hap}_realign.bam", sample=SAMPLES, hap=(1,2)),
  output:
    "data/lists/hap{hap}/{population}_realign_hap{hap}.txt"
  wildcard_constraints:
    population="|".join(POPULATIONS)
  run:
    bam_files = input
    output_file = output[0]
    population = wildcards.population
    hap = wildcards.hap

    with open(output_file, "w") as output:
        for bam_file in bam_files:
            if population in bam_file and f"_hap{hap}_" in bam_file:
                output.write(f"{bam_file}\n")


# Call SNPs with stringent rules for input to ngsParalog
# Question:  is -minInd 3 and -SNP_pvalue 0.05 so very liberal SNP calls
rule angsd_raw_SNP:
  input:
    bam_list="data/lists/hap{hap}/{population}_realign_hap{hap}.txt"
  output:
    arg_file="results/angsd/hap{hap}/raw_realign/{population}_raw_SNPs_realign.arg",
    mafs_file="results/angsd/hap{hap}/raw_realign/{population}_raw_SNPs_realign.mafs.gz",
    hwe_file="results/angsd/hap{hap}/raw_realign/{population}_raw_SNPs_realign.hwe.gz",
    depth_sample="results/angsd/hap{hap}/raw_realign/{population}_raw_SNPs_realign.depthSample",
    depth_global="results/angsd/hap{hap}/raw_realign/{population}_raw_SNPs_realign.depthGlobal"
  params:
    ref="data/reference/hap{hap}/lupinehap{hap}.fasta",
    file_name="results/angsd/hap{hap}/raw_realign/{population}_raw_SNPs_realign",
    hap="{hap}",
    population="{population}"
  log:
    "results/logs/angsd/hap{hap}/raw_realign/angsd_SNP_raw_hap{hap}_{population}.log"
  envmodules:
    "angsd/0.939"
  threads: 8
  shell:
    """
    angsd -bam {input.bam_list} -ref {params.ref}\
    -out {params.file_name}\
    -remove_bads 1\
    -C 50\
    -GL 1\
    -SNP_pval 0.05\
    -minMapQ 30\
    -minQ 20 \
    -minInd 5\
    -minMaf .05\
    -baq 2\
    -only_proper_pairs 1\
    -nThreads {threads}\
    -doHWE 1\
    -doCounts 1\
    -doDepth 1\
    -doMajorMinor 1\
    -doMaf 2\
    &> {log}
    """


# Create BED files so including only SNPs into ngsParalog
# NOTE: BED files indexed at 0bp because SAMtools to create pileup requires 0bp index
rule convert_mafs_to_bed_stringent:
  input:
    mafs_gz="results/angsd/hap{hap}/raw_realign/{population}_raw_SNPs_realign.mafs.gz"
  output:
    bed_file="results/bed/hap{hap}/raw_realign/{population}_raw_SNPs_realign.BED"
  shell:
   """
   gunzip -c {input.mafs_gz} | awk 'NR>1 {{print $1, $2 - 1, $2}}' > {output.bed_file}
   dos2unix {output.bed_file}  # Add this line to convert line endings
   """

  
# Create wildcard for scaffold names - needed to run ngsParalog per scaffold 
rule extract_scaffolds:
  input:
    index="data/reference/hap{hap}/lupinehap{hap}.fasta.fai"
  output:
    scaffolds="results/scaffolds/hap{hap}_scaffolds.txt"
  shell:
    """
    awk '{{print $1":1-"$2}}' {input.index} > {output.scaffolds}
    """


# Run ngsParalog on all SNPs across the genome (parallelized by running 1 job per scaffold)
rule ngsParalog_hap1: 
  input:
    bam_ngsPara=lambda wildcards: expand("results/bam_realign/hap1/{sample}_hap1_realign.bam", sample=[s for s in SAMPLES if s.startswith(wildcards.population)]),
    ref="data/reference/hap1/lupinehap1.fasta",
    bed_file="results/bed/hap1/raw_realign/{population}_raw_SNPs_realign.BED"
  output:
    paralog_output="results/ngs_paralog/hap1/realign/{population}_scaffolds/{population}-{hap1scaffold_prefix}.lr"
  log:
    "results/logs/ngs_paralog/hap1/realign/{population}_scaffolds/{population}-{hap1scaffold_prefix}.log"
  params:
    hap1scaffold=lambda wildcards: map_prefix_to_full_scaffold(wildcards.hap1scaffold_prefix, 1)
  envmodules:
    "samtools/1.17"
  shell:
    """
    rm -f {output.paralog_output} #remove existing output file if it exists
    touch {output.paralog_output}
    samtools mpileup {input.bam_ngsPara} -d 1000 -q 0 -Q 0 --ff UNMAP,QCFAIL,DUP \
    -l {input.bed_file} -r {params.hap1scaffold} -f {input.ref} 2>> {log} | \
    /home/socamero/ngsParalog/ngsParalog calcLR -infile - -outfile {output.paralog_output} -allow_overwrite 1 \
    -minQ 20 -minind 10 -mincov 1 \
    -runinfo 1 \
    2>> {log} || true
    """


rule ngsParalog_hap2:
  input:
    bam_ngsPara=lambda wildcards: expand("results/bam_realign/hap2/{sample}_hap2_realign.bam", sample=[s for s in SAMPLES if s.startswith(wildcards.population)]),
    ref="data/reference/hap2/lupinehap2.fasta",
    bed_file="results/bed/hap2/raw_realign/{population}_raw_SNPs_realign.BED"
  output:
    paralog_output="results/ngs_paralog/hap2/realign/{population}_scaffolds/{population}-{hap2scaffold_prefix}.lr"
  log:
    "results/logs/ngs_paralog/hap2/realign/{population}_scaffolds/{population}-{hap2scaffold_prefix}.log"
  params:
    hap2scaffold=lambda wildcards: map_prefix_to_full_scaffold(wildcards.hap2scaffold_prefix, 2)
  envmodules:
    "samtools/1.17"
  shell:
    """
    rm -f {output.paralog_output} #remove existing output file if it exists
    touch {output.paralog_output}
    samtools mpileup {input.bam_ngsPara} -d 1000 -q 0 -Q 0 --ff UNMAP,QCFAIL,DUP \
    -l {input.bed_file} -r {params.hap2scaffold} -f {input.ref} 2>> {log} | \
    /home/socamero/ngsParalog/ngsParalog calcLR -infile - -outfile {output.paralog_output} -allow_overwrite 1 \
    -minQ 20 -minind 10 -mincov 1 \
    -runinfo 1 \
    2>> {log} || true
    """


# Combine all ngsParalog outputs together into one file per population
rule concatenate_paralog_hap1:
  input:
    scaffold_files=lambda wildcards: expand("results/ngs_paralog/hap1/realign/{population}_scaffolds/{{population}}-{hap1scaffold_prefix}.lr", population=wildcards.population, hap1scaffold_prefix=HAP1SCAFFOLD_PREFIXES)
  output:
    paralog_final="results/ngs_paralog/hap1/concat_realign/{population}_paralog_realign_WGS.lr"
  log:
    "results/logs/ngs_paralog/hap1/concat_realign/{population}_paralog_realign_WGS.log"
  shell:
    """
    cat {input.scaffold_files} >> {output.paralog_final}
    """


rule concatenate_paralog_hap2:
  input:
    scaffold_files=lambda wildcards: expand("results/ngs_paralog/hap2/realign/{population}_scaffolds/{{population}}-{hap2scaffold_prefix}.lr", population=wildcards.population, hap2scaffold_prefix=HAP2SCAFFOLD_PREFIXES)
  output:
    paralog_final="results/ngs_paralog/hap2/concat_realign/{population}_paralog_realign_WGS.lr"
  log:
    "results/logs/ngs_paralog/hap2/concat_realign/{population}_paralog_realign_WGS.log"
  shell:
    """
    cat {input.scaffold_files} >> {output.paralog_final}
    """


# Identify false positives from ngsParalog (grab only true Paralogs) and filter out
# NOTE: R script indexes positions back to 1bp start
rule ngsParalog_false_pos:
  input:
    lr_file="results/ngs_paralog/hap{hap}/concat_realign/{population}_paralog_realign_WGS.lr"
  output:
    deviant_snps="results/bed/hap{hap}/deviant_SNPs_realign/{population}_deviant_SNPs_realign_BH_correction.BED",
    deviant_snps_bp1="results/bed/hap{hap}/deviant_SNPs_realign/{population}_deviant_SNPs_realign_bp1_BH_correction.lr"
  envmodules:
    "r/4.3.1"
  shell:
    """
    Rscript scripts/ngs_paralog_false_pos.R {input.lr_file} {output.deviant_snps} {output.deviant_snps_bp1}
    """


# For varying levels of Benjamini Hochberg critical values
rule ngsParalog_false_pos_BH:
  input:
    lr_file="results/ngs_paralog/hap{hap}/concat_realign/{population}_paralog_realign_WGS.lr"
  output:
    deviant_snps_bp1_BH="results/bed/hap{hap}/deviant_SNPs_realign/BH_correction/{population}_deviant_SNPs_bp1_realign_BH{BH_VAR}.lr"
  params:
    BH_VAR="{BH_VAR}"
  envmodules:
    "r/4.3.1"
  shell:
    """
    Rscript scripts/ngs_paralog_false_pos_BH.R {input.lr_file} {output.deviant_snps_bp1_BH} {params.BH_VAR}
    """


# Create Manhattan Plots [NOTE: Specific Scaffold # otherwise it'll take forever for whole genome!] 
rule ngsParalog_manhattan:
  input:
    lr_file="results/ngs_paralog/hap{hap}/realign/{population}_scaffolds/{population}-Scaffold_1.lr"
  output:
    plot="results/ngs_paralog/plots_realign/hap{hap}/{population}_manhattan_plot_realign_scaffold_1.png"
  envmodules:
    "r/4.3.1"
  threads: 2
  shell:
    "Rscript scripts/ngs_paralog_graphs.R {input.lr_file} {output.plot}"


# Generate average depth of coverage per site for dupHMM
# Only estimate at sites deemed 'paralogous' from raw ngsParalog (pre BH filter)
rule calculate_average_coverage_per_population:
  input:
    bam_files=lambda wildcards: expand("results/bam_realign/hap{hap}/{sample}_hap{hap}_realign.bam", sample=[s for s in SAMPLES if s.startswith(wildcards.population)], hap=(1,2)),
    raw_lr="results/ngs_paralog/hap{hap}/concat_realign/{population}_paralog_realign_WGS.lr"
  output:
    bed="results/bed/hap{hap}/deviant_SNPs_realign/{population}_deviant_SNPs_realign.BED",
    avg_cov_file="results/coverage_realign/hap{hap}/{population}_average_coverage.tsv"
  threads: 2
  log:
    "results/logs/coverage/hap{hap}/{population}_average_coverage.log"
  envmodules:
    "samtools/1.17"
  shell:
    """
    # Convert .lr file to BED format (0-based start)
    awk '{{print $1 "\\t" ($2-1) "\\t" $2}}' {input.raw_lr} > {output.bed}

    # Calculate the average coverage per position for all BAM files together using the BED file
    samtools depth -q 0 -Q 0 -J -a -b {output.bed} {input.bam_files} | \
    awk '{{cov[$1"\\t"$2]+=$3; count[$1"\\t"$2]++}} END {{for (pos in cov) print pos, cov[pos] / count[pos]}}' | \
    sort -k1,1V -k2,2n > {output.avg_cov_file}
    """



# Reduce deviant SNP calls to the number of known sites with depth data.
# In other words, ANGSD used imputation and was able to call more SNPs than the raw data in BAM files
# ANGSD does estimate depth globally and per individual, but NOT per site (see -doDepth 1)
rule filter_lr_by_coverage:
  input:
    lr_file="results/ngs_paralog/hap{hap}/concat_realign/{population}_paralog_realign_WGS.lr",
    cov_file="results/coverage_realign/hap{hap}/{population}_average_coverage.tsv"
  output:
    filtered_lr="results/bed/hap{hap}/deviant_SNPs_realign/{population}_coverage_only_paralog_realign_WGS.lr"
  log:
    "results/logs/filter_lr/hap{hap}/{population}_filtered_deviant_SNPs_realign.log"
  shell:
    """
    # Filter the .lr file based on the coverage file, ensuring no empty lines
    awk 'NR==FNR && $0!="" {{cov[$1" "$2]=1; next}} $0!="" && cov[$1" "$2] {{print}}' {input.cov_file} {input.lr_file} > {output.filtered_lr}
    """


# Set parameters for dupHMM to infer transitions between dup maps and normal mapping regions
rule dupHMM_setup:
  input:
    lr_file = "results/bed/hap{hap}/deviant_SNPs_realign/{population}_coverage_only_paralog_realign_WGS.lr",
    cov_file = "results/coverage_realign/hap{hap}/{population}_average_coverage.tsv"
  output:
    param_output = "results/ngs_paralog/hap{hap}/dupHMM_realign/{population}_dupHMM_realign.par"
  params:
    r_script_path = "/home/socamero/ngsParalog/dupHMM.R",
    name_output = "results/ngs_paralog/hap{hap}/dupHMM_realign/{population}_dupHMM_realign"
  log:
    "results/logs/ngs_paralog/hap{hap}/dupHMM_realign/{population}_dupHMM_realign_setup.log"
  envmodules:
    "r/4.3.1"
  shell:
    """
    Rscript {params.r_script_path} --lrfile {input.lr_file} \
    --outfile {params.name_output} \
    --covfile {input.cov_file} \
    --lrquantile 0.98 \
    --paramOnly 1 \
    2> {log}
    """


# Now generate coverage per scaffold and per population
rule calculate_coverage_per_population_and_scaffold_hap1:
  input:
    bam_files=lambda wildcards: expand("results/bam_realign/hap1/{sample}_hap1_realign.bam", sample=[s for s in SAMPLES if s.startswith(wildcards.population)]),
    raw_lr="results/ngs_paralog/hap1/realign/{population}_scaffolds/{population}-{hap1scaffold_prefix}.lr"
  output:
    bed="results/bed/hap1/deviant_SNPs_realign/{population}_scaffolds/{population}_{hap1scaffold_prefix}.BED",
    avg_cov_file="results/coverage_realign/hap1/{population}_scaffolds/{population}_{hap1scaffold_prefix}_average_coverage.tsv"
  log:
    "results/logs/coverage_realign/hap1/{population}_scaffolds/{population}_{hap1scaffold_prefix}_average_coverage.log"
  threads: 2
  envmodules:
    "samtools/1.17"
  shell:
    """
    # Check if the .lr file is empty and create a BED file accordingly
    if [ -s {input.raw_lr} ]; then
      # Convert non-empty .lr file to BED format (0-based start)
      awk '{{print $1 "\\t" ($2-1) "\\t" $2}}' {input.raw_lr} > {output.bed}
    else
      # Create an empty BED file if .lr file is empty
      touch {output.bed}
    fi

    # If the BED file is not empty, calculate the average coverage
    if [ -s {output.bed} ]; then
      samtools depth -@ 2 -q 0 -Q 0 -J -a -b {output.bed} {input.bam_files} | \
      awk '{{cov[$1"\\t"$2]+=$3; count[$1"\\t"$2]++}} END {{for (pos in cov) print pos, cov[pos] / count[pos]}}' | \
      sort -k1,1V -k2,2n > {output.avg_cov_file}
    else
      # Create an empty average coverage file if BED file is empty
      touch {output.avg_cov_file}
    fi
    """


rule calculate_coverage_per_population_and_scaffold_hap2:
  input:
    bam_files=lambda wildcards: expand("results/bam_realign/hap2/{sample}_hap2_realign.bam", sample=[s for s in SAMPLES if s.startswith(wildcards.population)]),
    raw_lr="results/ngs_paralog/hap2/realign/{population}_scaffolds/{population}-{hap2scaffold_prefix}.lr"
  output:
    bed="results/bed/hap2/deviant_SNPs_realign/{population}_scaffolds/{population}_{hap2scaffold_prefix}.BED",
    avg_cov_file="results/coverage_realign/hap2/{population}_scaffolds/{population}_{hap2scaffold_prefix}_average_coverage.tsv"
  log:
    "results/logs/coverage_realign/hap2/{population}_scaffolds/{population}_{hap2scaffold_prefix}_average_coverage.log"
  threads: 2
  envmodules:
    "samtools/1.17"
  shell:
    """
    # Check if the .lr file is empty and create a BED file accordingly
    if [ -s {input.raw_lr} ]; then
      # Convert non-empty .lr file to BED format (0-based start)
      awk '{{print $1 "\\t" ($2-1) "\\t" $2}}' {input.raw_lr} > {output.bed}
    else
      # Create an empty BED file if .lr file is empty
      touch {output.bed}
    fi

    # If the BED file is not empty, calculate the average coverage
    if [ -s {output.bed} ]; then
      samtools depth -@ 2 -q 0 -Q 0 -J -a -b {output.bed} {input.bam_files} | \
      awk '{{cov[$1"\\t"$2]+=$3; count[$1"\\t"$2]++}} END {{for (pos in cov) print pos, cov[pos] / count[pos]}}' | \
      sort -k1,1V -k2,2n > {output.avg_cov_file}
    else
      # Create an empty average coverage file if BED file is empty
      touch {output.avg_cov_file}
    fi
    """

rule filter_scaffold_lr_by_coverage_hap1:
  input:
    lr_file="results/ngs_paralog/hap1/realign/{population}_scaffolds/{population}-{hap1scaffold_prefix}.lr",
    cov_file="results/coverage_realign/hap1/{population}_scaffolds/{population}_{hap1scaffold_prefix}_average_coverage.tsv"
  output:
    filtered_lr="results/bed/hap1/deviant_SNPs_realign/{population}_scaffolds/{population}_{hap1scaffold_prefix}_coverage_only_paralog_realign.lr"
  log:
    "results/logs/filter_lr/hap1/{population}_scaffolds/{population}_{hap1scaffold_prefix}_filtered_deviant_SNPs_realign.log"
  shell:
    """
    # Filter the .lr file based on the coverage file, ensuring no empty lines
    awk 'NR==FNR && $0!="" {{cov[$1" "$2]=1; next}} $0!="" && cov[$1" "$2] {{print}}' {input.cov_file} {input.lr_file} > {output.filtered_lr}

    # If the filtered file is empty, create an empty file
    if [ ! -s {output.filtered_lr} ]; then
      touch {output.filtered_lr}
    fi
    """


rule filter_scaffold_lr_by_coverage_hap2:
  input:
    lr_file="results/ngs_paralog/hap2/realign/{population}_scaffolds/{population}-{hap2scaffold_prefix}.lr",
    cov_file="results/coverage_realign/hap2/{population}_scaffolds/{population}_{hap2scaffold_prefix}_average_coverage.tsv"
  output:
    filtered_lr="results/bed/hap2/deviant_SNPs_realign/{population}_scaffolds/{population}_{hap2scaffold_prefix}_coverage_only_paralog_realign.lr"
  log:
    "results/logs/filter_lr/hap2/{population}_scaffolds/{population}_{hap2scaffold_prefix}_filtered_deviant_SNPs_realign.log"
  shell:
    """
    # Filter the .lr file based on the coverage file, ensuring no empty lines
    awk 'NR==FNR && $0!="" {{cov[$1" "$2]=1; next}} $0!="" && cov[$1" "$2] {{print}}' {input.cov_file} {input.lr_file} > {output.filtered_lr}

    # If the filtered file is empty, create an empty file
    if [ ! -s {output.filtered_lr} ]; then
      touch {output.filtered_lr}
    fi
    """

# Run dupHMM with beginning estimated parameters
# adjust --lrquantile based on manhattan plot! 
# adjust --maxcoverage based on .tsv files! Seems like some coverages are HIGH! ~50.. To be slightly conservative, choosing 20
rule dupHMM_run_hap1:
  input:
    lr_file = "results/ngs_paralog/hap1/realign/{population}_scaffolds/{population}-{hap1scaffold_prefix}.lr",
    cov_file = "results/coverage_realign/hap1/{population}_scaffolds/{population}_{hap1scaffold_prefix}_average_coverage.tsv",
    parameters = "results/ngs_paralog/hap1/dupHMM_realign/{population}_dupHMM_realign.par"
  output:
    paralog_region = "results/ngs_paralog/hap1/dupHMM_realign/{population}_scaffolds/{population}-{hap1scaffold_prefix}_dupHMM_realign_run.rf"
  params:
    r_script_path = "/home/socamero/ngsParalog/dupHMM.R",
    name_output = "results/ngs_paralog/hap1/dupHMM_realign/{population}_scaffolds/{population}-{hap1scaffold_prefix}_dupHMM_realign_run"
  log:
    "results/logs/ngs_paralog/hap1/dupHMM_realign/{population}_scaffolds/{population}-{hap1scaffold_prefix}_dupHMM_realign_run.log"
  envmodules:
    "r/4.3.1"
  shell:
    """
    if [ -s {input.lr_file} ]; then
        Rscript {params.r_script_path} --lrfile {input.lr_file} \
        --outfile {params.name_output} \
        --covfile {input.cov_file} \
        --lrquantile 0.98 \
        --maxcoverage 12 \
        --paramfile {input.parameters} \
        2> {log}
    else
        echo "Skipping empty .lr file: {input.lr_file}" >> {log}
        touch {output.paralog_region}
    fi
    """


rule dupHMM_run_hap2:
  input:
    lr_file = "results/ngs_paralog/hap2/realign/{population}_scaffolds/{population}-{hap2scaffold_prefix}.lr",
    cov_file = "results/coverage_realign/hap2/{population}_scaffolds/{population}_{hap2scaffold_prefix}_average_coverage.tsv",
    parameters = "results/ngs_paralog/hap2/dupHMM_realign/{population}_dupHMM_realign.par"
  output:
    paralog_region = "results/ngs_paralog/hap2/dupHMM_realign/{population}_scaffolds/{population}-{hap2scaffold_prefix}_dupHMM_realign_run.rf"
  params:
    r_script_path = "/home/socamero/ngsParalog/dupHMM.R",
    name_output = "results/ngs_paralog/hap2/dupHMM_realign/{population}_scaffolds/{population}-{hap2scaffold_prefix}_dupHMM_realign_run"
  log:
    "results/logs/ngs_paralog/hap2/dupHMM_realign/{population}_scaffolds/{population}-{hap2scaffold_prefix}_dupHMM_realign_run.log"
  envmodules:
    "r/4.3.1"
  shell:
    """
    if [ -s {input.lr_file} ]; then
        Rscript {params.r_script_path} --lrfile {input.lr_file} \
        --outfile {params.name_output} \
        --covfile {input.cov_file} \
        --lrquantile 0.98 \
        --maxcoverage 12 \
        --paramfile {input.parameters} \
        2> {log}
    else
        echo "Skipping empty .lr file: {input.lr_file}" >> {log}
        touch {output.paralog_region}
    fi
    """


# Some scaffolds only have 1 SNP with coverage and/or paralog data
# Some scaffolds don't meet the conditions for dupHMM (e.g outside of LR quantile range and too high coverage)




## STEP 3: VERIFY HETEROZYGOTE EXCESS REDUCED .. METHOD 1: RE-RUN ANGSD

# Print out all sites (monomorphic or not)
rule extract_all_sites_by_popln:
  input:
    bam_list="data/lists/hap{hap}/{population}_realign_hap{hap}.txt"
  output:
    all_sites_gz="results/angsd/hap{hap}/all_sites/{population}_all_sites.pos.gz",
    all_sites_arg="results/angsd/hap{hap}/all_sites/{population}_all_sites.arg",
    all_sites_bed="results/angsd/hap{hap}/all_sites/{population}_all_sites.BED"
  params:
    ref="data/reference/hap{hap}/lupinehap{hap}.fasta",
    angsd_out="results/angsd/hap{hap}/all_sites/{population}_all_sites"
  log:
    angsd_log="results/logs/angsd/hap{hap}/all_sites/{population}_all_sites.log"
  threads: 8
  envmodules:
    "angsd/0.939"
  shell:
    """
    # Extract all sites across the genome
    angsd -bam {input.bam_list} -ref {params.ref} -out {params.angsd_out} \
    -doCounts 1 -dumpCounts 1 -P 8 &> {log.angsd_log}

    # Convert the ANGSD output to a BED format file
    gunzip -c {params.angsd_out}.pos.gz | awk 'NR > 1 {{print $1, $2-1, $2}}' > {output.all_sites_bed}
    """


rule check_bed_files:
  input:
    all_sites_bed = "results/angsd/hap2/all_sites/{population}_all_sites.BED",
    deviant_snps_bed = "results/bed/hap2/deviant_SNPs_realign/{population}_deviant_SNPs_realign_BH_correction.BED"
  output:
    touch("results/checks/hap2/{population}_bed_files_checked.txt")
  log:
    "results/logs/check_bed/check_bed_files_hap2_{population}.log"
  shell:
    """
    echo "Checking files for population {wildcards.population}" >> {log}

    for bed_file in {input.all_sites_bed} {input.deviant_snps_bed}; do
        echo "Checking file: $bed_file" >> {log}

        # Check if file is tab-delimited and columns 2 and 3 are integers
        awk -F '\\t' 'BEGIN {{ OFS = FS; hasNonIntegers = 0; notTabDelimited = 0; }}
        {{
            if (NF < 3) {{ 
                notTabDelimited = 1; 
                exit; 
            }}
            if ($2 != int($2) || $3 != int($3)) {{ 
                hasNonIntegers = 1; 
                exit; 
            }}
        }}
        END {{
            if (notTabDelimited) {{ 
                print "ERROR: File is not tab-delimited or does not have at least 3 columns: " bed_file; 
            }} else if (hasNonIntegers) {{ 
                print "ERROR: File contains non-integer values in columns 2 or 3: " bed_file; 
            }} else {{ 
                print "OK: File passed checks: " bed_file; 
            }}
        }}' bed_file="$bed_file" >> {log}
    done
    """


# Format all BED files accordingly and make sure they're in UNIX format + tab delimited
rule preprocess_bed_files_all_populations:
  input:
    all_sites_bed="results/angsd/hap{hap}/all_sites/{population}_all_sites.BED",
    deviant_snps="results/bed/hap{hap}/deviant_SNPs_realign/{population}_deviant_SNPs_realign_BH_correction.BED"
  output:
    processed_all_sites_bed="results/angsd/hap{hap}/all_sites/{population}_all_sites_processed.BED",
    processed_deviant_snps="results/bed/hap{hap}/deviant_SNPs_realign/{population}_deviant_SNPs_realign_BH_correction_processed.BED"
  shell:
    """
    # Convert all_sites_bed BED file from DOS to UNIX line endings and process
    dos2unix {input.all_sites_bed}
    awk 'NF >= 3 {{print $1"\t"$2"\t"$3}}' {input.all_sites_bed} > {output.processed_all_sites_bed}

    # Convert deviant_snps BED file from DOS to UNIX line endings and process
    dos2unix {input.deviant_snps}
    awk 'NF >= 3 {{print $1"\t"$2"\t"$3}}' {input.deviant_snps} > {output.processed_deviant_snps}
    

    # Optional: Print lines before and after removal for auditing
    echo "Lines before processing in {input.all_sites_bed}:"
    wc -l {input.all_sites_bed}
    echo "Lines after processing in {output.processed_all_sites_bed}:"
    wc -l {output.processed_all_sites_bed}

    echo "Lines before processing in {input.deviant_snps}:"
    wc -l {input.deviant_snps}
    echo "Lines after processing in {output.processed_deviant_snps}:"
    wc -l {output.processed_deviant_snps}
    """


# Upon manual inspection, it seems that population PPP has a paralog data row that is malformed. We remove this manually
# We also incorporate this new check into the preprocessing rule. --> If any row has missing data, we remove that row. 
#sed -i '3272157d' results/bed/hap2/deviant_SNPs_realign/PPP_deviant_SNPs_realign_BH_correction_processed.BED


# Filter out deviant SNPs from all known sites
rule filter_all_sites_by_popln:
  input:
    processed_all_sites_bed="results/angsd/hap{hap}/all_sites/{population}_all_sites_processed.BED",
    processed_deviant_snps="results/bed/hap{hap}/deviant_SNPs_realign/{population}_deviant_SNPs_realign_BH_correction_processed.BED"
  output:
    filtered_sites_bed="results/bed/hap{hap}/filtered_sites/{population}_filtered_sites.BED",
    filtered_sites_txt="results/bed/hap{hap}/filtered_sites/{population}_filtered_sites.txt"
  log:
    bedtools_log="results/logs/bedtools/hap{hap}/filtered_sites/{population}_filtered_sites.log"
  envmodules:
    "bedtools/2.30.0"
  shell:
    """
    # Filter out deviant sites using bedtools
    bedtools subtract -a {input.processed_all_sites_bed} -b {input.processed_deviant_snps} > {output.filtered_sites_bed} \
    2> {log.bedtools_log}

    # Convert the filtered BED file to a .txt file formatted for -sites in ANGSD
    awk '{{print $1, $3}}' {output.filtered_sites_bed} > {output.filtered_sites_txt}
    """


# Index filtered all sites BED file
rule index_sites_all_popln_list:
  input: 
    canonical_sites = "results/bed/hap{hap}/filtered_sites/{population}_filtered_sites.txt"
  output: 
    bin_index = "results/bed/hap{hap}/filtered_sites/{population}_filtered_sites.txt.bin"
  envmodules:
    "angsd/0.939"
  shell: 
    """
    angsd sites index {input.canonical_sites}
    """

# Re-run ANGSD and calculate SFS to check of SNP filtering reduced heterozygote excess
# Run by population!
rule angsd_SFS_by_population_on_all_sites:
  input:
    bam_list="data/lists/hap{hap}/{population}_realign_hap{hap}.txt",
    canonical_sites="results/bed/hap{hap}/filtered_sites/{population}_filtered_sites.txt",
    bin_index="results/bed/hap{hap}/filtered_sites/{population}_filtered_sites.txt.bin"
  output:
    arg_file="results/angsd/hap{hap}/canonical_realign/by_popln/{population}_canonical_sites.arg",
    mafs_file="results/angsd/hap{hap}/canonical_realign/by_popln/{population}_canonical_sites.mafs.gz",
    hwe_file="results/angsd/hap{hap}/canonical_realign/by_popln/{population}_canonical_sites.hwe.gz",
    depth_sample="results/angsd/hap{hap}/canonical_realign/by_popln/{population}_canonical_sites.depthSample",
    depth_global="results/angsd/hap{hap}/canonical_realign/by_popln/{population}_canonical_sites.depthGlobal",
    saf_1="results/angsd/hap{hap}/canonical_realign/by_popln/{population}_canonical_sites.saf.idx",
    saf_2="results/angsd/hap{hap}/canonical_realign/by_popln/{population}_canonical_sites.saf.pos.gz",
    saf_3="results/angsd/hap{hap}/canonical_realign/by_popln/{population}_canonical_sites.saf.gz"
  params:
    ref="data/reference/hap{hap}/lupinehap{hap}.fasta",
    file_name="results/angsd/hap{hap}/canonical_realign/by_popln/{population}_canonical_sites"
  log:
    "results/logs/angsd/hap{hap}/canonical_realign/by_popln/angsd_canonical_sites_hap{hap}_{population}.log"
  envmodules:
    "angsd/0.939"
  threads: 16
  shell:
    """
    angsd -bam {input.bam_list} -ref {params.ref}\
    -out {params.file_name}\
    -remove_bads 1\
    -GL 1\
    -C 50\
    -sites {input.canonical_sites}\
    -minMapQ 30\
    -minQ 20 \
    -baq 2\
    -only_proper_pairs 1\
    -nThreads {threads}\
    -doHWE 1\
    -doCounts 1\
    -doDepth 1\
    -doMajorMinor 1\
    -doMaf 2\
    -doSaf 1\
    -anc {params.ref}\
    -doGlf 2\
    &> {log}
    """








# Optimize and calculate SFS with folded spectra (-fold 1) since ancestral state unknown
#rule calculate_realSFS:
  #input:
  #output:
  #shell:

#### POPULATION GENOMICS ####

# Run ANGSD on entire dataset, filtering paralogs from each population, and estimate SNPs + save GLs
# Rule to create .txt file of BAM files per population
rule generate_bam_list_all_populations:
  input:
    expand("results/bam_realign/hap{hap}/{sample}_hap{hap}_realign.bam", sample=SAMPLES, hap=(1,2)),
  output:
    "data/lists/hap{hap}/all_populations_realign_hap{hap}.txt"
  run:
    bam_files = input
    output_file = output[0]
    hap = wildcards.hap

    with open(output_file, "w") as output:
        for bam_file in bam_files:
            if f"_hap{hap}_" in bam_file:
                output.write(f"{bam_file}\n")


# Join together paralogs into one .BED file
rule combine_population_paralog_bed_files:
  input:
    expand("results/bed/hap{hap}/deviant_SNPs_realign/{population}_deviant_SNPs_realign_BH_correction.BED", hap=(1,2), population=POPULATIONS),
  output:
    "results/bed/hap{hap}/combined/hap{hap}_combined_deviant_SNPs_realign_BH_correction.BED"
  shell:
    """
    # Combine all BED files into one and remove duplicates
    cat {input} | sort -k1,1 -k2,2n | uniq > {output}
    """


# Extract all known sites from ALL populations. This is to create list sites and later filter from paralogs
rule extract_all_sites_all_populations:
  input:
    bam_list="data/lists/hap{hap}/all_populations_realign_hap{hap}.txt"
  output:
    all_sites_gz="results/angsd/hap{hap}/all_poplns/all_sites.pos.gz",
    all_sites_arg="results/angsd/hap{hap}/all_poplns/all_sites.arg",
    all_sites_bed="results/angsd/hap{hap}/all_poplns/all_sites.BED"
  params:
    ref="data/reference/hap{hap}/lupinehap{hap}.fasta",
    angsd_out="results/angsd/hap{hap}/all_poplns/all_sites"
  log:
    angsd_log="results/logs/angsd/hap{hap}/all_poplns/all_sites.log"
  threads: 16
  envmodules:
    "angsd/0.939"
  shell:
    """
    # Extract all sites across the genome for all populations
    angsd -bam {input.bam_list} -ref {params.ref} -out {params.angsd_out} \
    -doCounts 1 -dumpCounts 1 -P {threads} &> {log.angsd_log}

    # Convert the ANGSD output to a BED format file and check for completeness of data
    gzip -cd {params.angsd_out}.pos.gz | awk 'NR > 1 && NF >= 3 {{print $1"\t"$2-1"\t"$2}}' > {output.all_sites_bed}
    dos2unix {output.all_sites_bed}
    """


rule filter_all_sites_all_populations:
  input:
    all_sites_bed="results/angsd/hap{hap}/all_poplns/all_sites.BED",
    deviant_snps="results/bed/combined/hap{hap}_combined_deviant_SNPs_realign_BH_correction.BED"
  output:
    filtered_sites_bed="results/bed/hap{hap}/all_poplns/filtered_sites.BED",
    filtered_sites_txt="results/bed/hap{hap}/all_poplns/filtered_sites.txt"
  log:
    bedtools_log="results/logs/bedtools/hap{hap}/all_poplns/filtered_sites.log"
  envmodules:
    "bedtools/2.30.0"
  shell:
    """
    # Filter out deviant sites for all populations using bedtools
    bedtools subtract -a {input.all_sites_bed} -b {input.deviant_snps} > {output.filtered_sites_bed} \
    2> {log.bedtools_log}

    # Convert the filtered BED file to a .txt file formatted for -sites in ANGSD
    awk '{{print $1, $3}}' {output.filtered_sites_bed} > {output.filtered_sites_txt}
    """


# Estimate SAF, HWE, GL with SNPs on entire population
rule angsd_SNP_on_entire_population:
  input:
    bam_list="data/lists/hap{hap}/all_populations_realign_hap{hap}.txt",
    canonical_sites="results/bed/hap{hap}/all_poplns/filtered_sites.txt"
  output:
    arg_file="results/angsd/hap{hap}/canonical_realign/all_poplns/all_poplns_canonical_SNPs.arg",
    mafs_file="results/angsd/hap{hap}/canonical_realign/all_poplns/all_poplns_canonical_SNPs.mafs.gz",
    hwe_file="results/angsd/hap{hap}/canonical_realign/all_poplns/all_poplns_canonical_SNPs.hwe.gz",
    depth_sample="results/angsd/hap{hap}/canonical_realign/all_poplns/all_poplns_canonical_SNPs.depthSample",
    depth_global="results/angsd/hap{hap}/canonical_realign/all_poplns/all_poplns_canonical_SNPs.depthGlobal",
    saf_1="results/angsd/hap{hap}/canonical_realign/all_poplns/all_poplns_canonical_SNPs.saf.idx",
    saf_2="results/angsd/hap{hap}/canonical_realign/all_poplns/all_poplns_canonical_SNPs.saf.pos.gz",
    saf_3="results/angsd/hap{hap}/canonical_realign/all_poplns/all_poplns_canonical_SNPs.saf.gz"
  params:
    ref="data/reference/hap{hap}/lupinehap{hap}.fasta",
    file_name="results/angsd/hap{hap}/canonical_realign/all_poplns/all_poplns_canonical_SNPs",
  log:
    "results/logs/angsd/hap{hap}/canonical_realign/all_poplns/angsd_canonical_SNPs_hap{hap}_all_poplns.log"
  envmodules:
    "angsd/0.939"
  threads: 16
  shell:
    """
    angsd -bam {input.bam_list} -ref {params.ref}\
    -out {params.file_name}\
    -remove_bads 1\
    -GL 1\
    -C 50\
    -sites {input.canonical_sites}\
    -minMapQ 30\
    -minQ 20 \
    -baq 2\
    -only_proper_pairs 1\
    -nThreads {threads}\
    -SNP_pval 1e-6\
    -doHWE 1\
    -doCounts 1\
    -doDepth 1\
    -doMajorMinor 1\
    -doMaf 2\
    -dosaf 1
    -fold 1\
    -anc {params.ref}\
    -doGlf 2\
    &> {log}
    """



## ARCHIVED RULES ##

# Previously filtered deviant SNPs from hwe calculations to check F distribution... but this is a bad way because we did a very liberal SNP call.

# Filter out deviant SNP positions from hwe to check for heterozygote excess
rule filter_hwegz_from_deviant_SNPs:
  input:
    F_values = "results/angsd/hap{hap}/raw_realign/{population}_raw_SNPs_realign.hwe.gz",
    deviant_snps = "results/bed/hap{hap}/deviant_SNPs_realign/{population}_deviant_SNPs_bp1_realign.lr"
  output:
    filtered_Fs = "results/bed/hap{hap}/canonical_SNPs_realign/Method_A/hwe_{population}_canonical_SNPs_realign.lr"
  shell:
    """
    zcat {input.F_values} | awk 'NR==FNR{{pos[$2]; next}} $2 in pos' {input.deviant_snps} - > {output.filtered_Fs}
    """


rule filter_hwegz_from_deviant_SNPs_BH:
  input:
    F_values = "results/angsd/hap{hap}/raw_realign/{population}_raw_SNPs_realign.hwe.gz",
    deviant_snps = "results/bed/hap{hap}/deviant_SNPs_realign/BH_correction/{population}_deviant_SNPs_bp1_realign_BH{BH_VAR}.lr"
  output:
    filtered_Fs = "results/bed/hap{hap}/canonical_SNPs_realign/Method_A/BH_correction/hwe_{population}_canonical_SNPs_realign_BH{BH_VAR}.lr"
  shell:
    """
    zcat {input.F_values} | awk 'NR==FNR{{pos[$2]; next}} $2 in pos' {input.deviant_snps} - > {output.filtered_Fs}
    """


# Unzip hwe to extract desired variables (i.e F values)
rule unzip_hwe:
  input:
    zipped_hwe = "results/angsd/hap{hap}/raw_realign/{population}_raw_SNPs_realign.hwe.gz"
  output:
    unzip_hwe = "results/bed/hap{hap}/raw_SNPs_realign/hwe_{population}_raw_SNPs_realign.lr"
  shell:
    """
    zcat {input.zipped_hwe} > {output.unzip_hwe}
    """


# Create histogram of F values (includes header)
rule excess_heterozygotes_histogram_raw:
  input:
    hwe_file = "results/angsd/hap{hap}/raw_realign/hwe_{population}_raw_SNPs_realign.lr"
  output:
    plot = "results/angsd/hap{hap}/plots_realign/HETERO_EXCESS_{population}_SNP_raw_realign.png"
  envmodules:
    "r/4.3.1"
  shell:
    "Rscript scripts/hetero_excess_header.R {input.hwe_file} {output.plot}"


# Create histogram of F values for canonical SNPs (excludes header)
rule excess_heterozygotes_histogram_canonical:
  input:
    lr_file = "results/bed/hap{hap}/canonical_SNPs_realign/Method_A/hwe_{population}_canonical_SNPs_realign.lr"
  output:
    plot = "results/angsd/hap{hap}/plots_realign/BH_correction/HETERO_EXCESS_{population}_SNP_canonical_realign.png"
  envmodules:
    "r/4.3.1"
  shell:
    "Rscript scripts/hetero_excess_noheader.R {input.lr_file} {output.plot}"


# Create and group multiple histograms into one file per population, for F values of canonical SNPs
# Checkpoint to determine all BH_VAR files for a given population and hap
checkpoint excess_heterozygotes_files:
  input:
    expand("results/angsd/hap{{hap}}/canonical_realign/Method_A/BH_correction/hwe_{{population}}_canonical_SNPs_realign_BH{BH_VAR}.lr", BH_VAR=BH_VARS)
  output:
    touch("results/angsd/hap{{hap}}/canonical_realign/Method_A/BH_correction/{{population}}_files.done")


# Aggregate rule for each population
rule aggregate_excess_heterozygotes_histograms_canonical:
  input:
    hwe_files = lambda wildcards: expand("results/bed/hap{hap}/canonical_SNPs_realign/Method_A/BH_correction/hwe_{population}_canonical_SNPs_realign_BH{BH_VAR}.lr", 
                                         hap=wildcards.hap, population=wildcards.population, BH_VAR=BH_VARS)
  output:
    plot = "results/angsd/hap{hap}/plots_realign/BH_correction/HETERO_EXCESS_{population}_SNP_canonical_BH_aggregate_realign_BIG.png"
  envmodules:
    "r/4.3.1"
  shell:
    """
    Rscript scripts/hetero_excess_BH.R {input.hwe_files} {output.plot}
    """